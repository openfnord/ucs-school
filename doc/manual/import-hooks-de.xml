<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE chapter [
	<!ENTITY % extensions SYSTEM "../stylesheets/macros.ent" >
	<!ENTITY % DocBookDTD PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	<!ENTITY % entities SYSTEM "../stylesheets/macros-de.ent" >
	%extensions;
	%DocBookDTD;
	%entities;
]>
<chapter id="pyhooks">
  <title>Python-Hooks</title>
  <para>
	Ab &ucsUAS; 4.4 v9 kann vor und nach dem Anlegen, Ändern, Verschieben und Löschen von &ucsUAS; Objekten Python-Code ausgeführt werden. Dies kann z.B. im Rahmen des &ucsUAS; Imports von eingesetzt werden, um in Abhängigkeit von der
	jeweiligen Umgebung zusätzlich einige weitere Einstellungen vorzunehmen.
  </para>
      <para>
          Python-Hooks (im folgenden Abschnitt abgekürzt mit "Hooks") erlauben eine feingranulare Unterscheidung nach Objekttypen (z.B. Schulklasse und Arbeitsgruppe oder Schüler und Lehrer) und haben Zugriff auf alle Attribute der Objekte.
      </para>
      <para>
          Die Hooks werden für alle Klassen, von denen Objekte erzeugt werden können und die von <classname>ucsschool.lib.models.base.UCSSchoolHelperAbstractClass</classname> ableiten, ausgeführt.
          Diese Klassen finden sich in im Python Paket <classname>ucsschool.lib.models</classname> (z.B. <classname>Student</classname>, <classname>SchoolClass</classname>, <classname>Workgroup</classname>).
      </para>
      <caution>
          <para>
              Hooks werden nur auf dem System ausgeführt, auf dem sie installiert sind.
              In der Regel ist das der &ucsPrimaryDN; (DC Master), sowie alle Backup Directory Nodes (DC Backups).
              Sollen Hooks auch auf Replication Nodes (DC Slave) ausgeführt werden, so müssen sie auch dort installiert werden.
              Eine automatische Verteilung der Hook Dateien findet nicht statt.
          </para>
      </caution>
      <para>
          Hooks für &ucsUAS; Objekte ähneln den bekannten Hooks für den Benutzerimport (siehe <biblioref linkend="ucs-school-cli-import"/>), werden jedoch auch ohne den Import zu verwenden ausgeführt und haben einige andere Attribute.
      </para>
      <para>
          Zur Nutzung der Hook-Funktionalität muss eine eigene Python-Klasse erstellt werden, die von <classname>ucsschool.lib.models.hook.Hook</classname> ableitet.
          In der Klasse können Methoden <methodname>pre_create()</methodname>, <methodname>post_create()</methodname>, etc. definiert werden, welche zum jeweiligen Zeitpunkt ausgeführt werden.
          Der Name der Datei mit der abgeleiteten Klasse muss auf <filename>.py</filename> enden und im Verzeichnis <filename class="directory">/var/lib/ucs-school-lib/hooks</filename> abgespeichert werden.
          Zwei Beispiele finden sich auf Servern der Rolle &ucsPrimaryDN; (DC Master) in <filename>hook_example1.py</filename> und <filename>hook_example2.py</filename> unter <filename class="directory">/usr/share/doc/ucs-school-lib-common/</filename> bzw. online auf <ulink url="https://github.com/univention/ucs-school/blob/5.0/ucs-school-lib/usr/share/doc/ucs-school-lib-common/hook_example1.py">https://github.com/.../hook_example1.py</ulink> und <ulink url="https://github.com/univention/ucs-school/blob/5.0/ucs-school-lib/usr/share/doc/ucs-school-lib-common/hook_example2.py">https://github.com/.../hook_example2.py</ulink>.
          Im Folgenden wird anhand des Beispiels in <filename>hook_example2.py</filename> erklärt, wie mit Hilfe eines Hooks jeder Schulklasse eine Email-Adresse zugeordnet werden kann.
      </para>
      <caution>
          <para>
              Das Beispiel ist lauffähig, aber nicht für den Produktivbetrieb geeignet.
              Dafür bräuchte es u.a. zusätzlichen Code, um robust mit existierenden Email-Adressen umzugehen.
          </para>
      </caution>
      <para>
          Ein Python-Hook ist eine Klasse, die von <classname>ucsschool.lib.models.hook.Hook</classname> ableitet und einige Attribute und Methoden definiert.
          <programlisting language="python">
from ucsschool.lib.models.group import SchoolClass
from ucsschool.lib.models.hook import Hook

class MailForSchoolClass(Hook):
    model = SchoolClass
    priority = {
        "post_create": 10,
        "post_modify": 10,
    }

    def post_create(self, obj):  # type: (SchoolClass) -> None
        ...

    def post_modify(self, obj):  # type: (SchoolClass) -> None
        ...
          </programlisting>
      </para>
      <para>
          Das Klassenattribut <property>model</property> bestimmt, für welche Objekte welchen Typs der Hook ausgeführt wird.
          Der Hook wird auch für Objekte von Klassen ausgeführt, die von der angegebenen ableiten.
          Wäre <code>model = Teacher</code> (aus <classname>ucsschool.lib.models</classname>), so würde der Hook auch für Objekte der Klasse <classname>TeachersAndStaff</classname> ausgeführt, nicht aber für solche vom Typ <classname>Staff</classname> oder <classname>Student</classname>.
      </para>
      <para>
          Das Klassenattribut <property>priority</property> bestimmt die Reihenfolge in der Methoden von Hooks des gleichen Typs (gleiches <property>model</property>) ausgeführt werden bzw. deaktiviert sie.
          Methoden mit höheren Zahlen werden zuerst ausgeführt.
          Ist der Wert <varname>None</varname> oder die Methode nicht aufgeführt, wird sie deaktiviert.
          Angenommen es gäbe eine weitere Klasse mit einem Hook mit <code>model = SchoolClass</code> und diese würde <code>priority = {"post_create": 20}</code> definieren, so würde deren <methodname>post_create()</methodname> Methode <emphasis>vor</emphasis> <methodname>MailForSchoolClass.post_create()</methodname> ausgeführt.
      </para>
      <para>
          Alle Methoden der Klasse, z.B. <methodname>pre_create()</methodname> oder <methodname>post_create()</methodname>, empfangen ein Objekt vom Typ, bzw. des davon abgeleiteten Typs, der in <property>model</property> definiert wurde, als Argument <varname>obj</varname> und geben nichts zurück.
      </para>
      <para>
          Die <methodname>post_create()</methodname> Methode sieht wie folgt aus:
          <programlisting language="python">
def post_create(self, obj):  # type: (SchoolClass) -> None
"""
Create an email address for the new school class.

:param SchoolClass obj: the SchoolClass instance, that was just created.
:return: None
"""
    ml_name = self.name_for_mailinglist(obj)
    self.logger.info("Setting email address %r on school class %r...", ml_name, obj.name)
    udm_obj = obj.get_udm_object(self.lo)  # access the underlying UDM object
    udm_obj["mailAddress"] = ml_name
    udm_obj.modify()
          </programlisting>
          Die Klasse <classname>SchoolClass</classname> bietet kein Attribut an, um eine Email-Adresse anzugeben.
          Die Klassen in <classname>ucsschool.lib.models</classname> sind jedoch tatsächlich eine Abstraktion regulärer &ucsUDM; Objekte.
          Um auf auf die darunter liegenden Objekte zuzugreifen, wird die Methode <methodname>get_udm_object()</methodname> verwendet.
          Als Argument muss ihr ein sogenanntes LDAP Verbindungsobjekt (<varname>lo</varname>) mitgegeben werden.
      </para>
      <para>
          Die Instanzvariablen <property>self.lo</property>, <property>self.logger</property> und <property>self.ucr</property> sind nach der Ausführung von <methodname>__init__()</methodname> verfügbar.
          Es handelt sich bei ihnen um die Instanz eines LDAP Verbindungsobjekts, einer Instanz von Python <classname>Logging</classname> und einer Instanz von &ucsUCR;.
          Soll eigener Code zur Initialisierung ausgeführt werden, so sollte <methodname>__init__()</methodname> folgendermaßen implementiert werden:
          <programlisting language="python">
class MailForSchoolClass(Hook):
    def __init__(self, lo, *args, **kwargs):
        super(MailForSchoolClass, self).__init__(lo, *args, **kwargs)
        # From here on self.lo, self.logger and self.ucr are available.
        # You code here.
          </programlisting>
      </para>
      <para>
          Zwei Funktionen helfen dabei, aus dem Namen der Schulklasse und einem Domänennamen, eine Email-Adresse zu erzeugen:
          <programlisting language="python">
def name_for_mailinglist(self, obj):  # type: (SchoolClass) -> str
    return "{}@{}".format(obj.name, self.domainname).lower()

@property
def domainname(self):  # type: () -> str
    try:
        return self.ucr["mail/hosteddomains"].split()[0]
    except (AttributeError, IndexError):
        return self.ucr["domainname"]
          </programlisting>
      </para>
      <para>
          Um Email-Adresse auch für umbenannte Schulklassen zu ändern, wird <methodname>post_modify</methodname> implementiert:
          <programlisting language="python">
def post_modify(self, obj):  # type: (SchoolClass) -> None
    """
    Change the email address of an existing school class.

    :param SchoolClass obj: the SchoolClass instance, that was just modified.
    :return: None
    """
    udm_obj = obj.get_udm_object(self.lo)
    ml_name = self.name_for_mailinglist(obj)
    if udm_obj["mailAddress"] != ml_name:
        self.logger.info(
            "Changing the email address of school class %r from %r to %r...",
            obj.name,
            udm_obj["mailAddress"],
            ml_name,
        )
        udm_obj["mailAddress"] = ml_name
        udm_obj.modify()
          </programlisting>
      </para>
      <para>
          Die Datei mit obigem Python Code kann nun im Verzeichnis <filename class="directory">/var/lib/ucs-school-lib/hooks</filename> abgespeichert werden.
          Soll der Hook von einem UMC-Modul verwendet werden, muss zuerst der UMC-Server neu gestartet werden:
          <programlisting language="sh">
service univention-management-console-server restart
          </programlisting>
          Um den Hook zu testen, kann eine interaktive Python Shell verwendet werden.
          Einige Ausgaben wurden im folgenden Beispiel zur Verbesserung der Lesbarkeit gekürzt:
          <programlisting language="python">
>>> import logging
>>> from ucsschool.lib.models.group import SchoolClass
>>> from univention.admin.uldap import getAdminConnection

>>> logging.basicConfig(level=logging.DEBUG, format="%(message)s", handlers=[logging.StreamHandler()])
>>> lo, _ = getAdminConnection()

>>> sc = SchoolClass(name="DEMOSCHOOL-igel", school="DEMOSCHOOL")
>>> sc.create(lo)

Starting SchoolClass.call_hooks('pre', 'create', lo('cn=admin,dc=exam,dc=ple')) for SchoolClass(
    name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-igel,cn=klassen,cn=schueler,
    cn=groups,ou=DEMOSCHOOL,dc=exam,dc=ple').
Hook directory /usr/share/ucs-school-import/hooks/group_create_pre.d not found or empty.
Searching for hooks of type 'Hook' in: /var/lib/ucs-school-lib/hooks...
Found hook classes: MailForSchoolClass
Loaded hooks: {'post_modify': ['MailForSchoolClass.post_modify'], 'post_create': [
    'MailForSchoolClass.post_create']}.
Creating SchoolClass(name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='...')
SchoolClass(name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='...') successfully created
Starting SchoolClass.call_hooks('post', 'create', lo('cn=admin,dc=uni,dc=dtr')) for SchoolClass(
    name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='...').
Hook directory /usr/share/ucs-school-import/hooks/group_create_post.d not found or empty.
Running post_create hook MailForSchoolClass.post_create for SchoolClass(name='DEMOSCHOOL-igel',
    school='DEMOSCHOOL', dn='...')...
Setting email address 'demoschool-igel@uni.dtr' on SchoolClass(name='DEMOSCHOOL-igel',
    school='DEMOSCHOOL', dn='...')...
True

>>> sc.name = "DEMOSCHOOL-hase"
>>> sc.modify(lo)

Starting SchoolClass.call_hooks('pre', 'modify', lo('cn=admin,dc=exam,dc=ple')) for SchoolClass(
    name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...', old_dn='cn=DEMOSCHOOL-igel,...').
Hook directory /usr/share/ucs-school-import/hooks/group_modify_pre.d not found or empty.
Modifying SchoolClass(name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...',
    old_dn='cn=DEMOSCHOOL-igel,...')
SchoolClass(name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...') successfully modified
Starting SchoolClass.call_hooks('post', 'modify', lo('cn=admin,dc=exam,dc=ple')) for SchoolClass(
    name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...').
Hook directory /usr/share/ucs-school-import/hooks/group_modify_post.d not found or empty.
Running post_modify hook MailForSchoolClass.post_modify for SchoolClass(name='DEMOSCHOOL-hase',
    school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...')...
Changing the email address of SchoolClass(name='DEMOSCHOOL-hase', school='DEMOSCHOOL', ...)
    from 'demoschool-igel@example.com' to 'demoschool-hase@example.com'...
True
          </programlisting>
          Vor dem Anlegen des Objekts wird in <filename class="directory">/usr/share/ucs-school-import/hooks/group_create_pre.d/</filename> nach den Hook-Skripte  gesucht, welche ab &ucsUAS; 5.0 nicht mehr unterstützt werden.
          Anschließend wird in <filename class="directory">/var/lib/ucs-school-lib/hooks/</filename> nach Python-Hooks gesucht und die Klasse <classname>MailForSchoolClass</classname> gefunden.
          Nach dem Laden aller Hooks wird angezeigt, in welcher Reihenfolge welche Methoden für welche Phase ausgeführt werden.
          Da es keine <varname>pre-create</varname> Hooks gibt, wird nun das Objekt angelegt.
          Anschließend werden <varname>post-create</varname> Hooks ausgeführt.
          Erneut wird zuerst nach Hook-Skripten gesucht.
          Anschließend wird <methodname>MailForSchoolClass.post_create()</methodname> ausgeführt.
          Beim <methodname>sc.modify(lo)</methodname> passiert das Gleiche.
      </para>
</chapter>
