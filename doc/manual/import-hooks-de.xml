<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE chapter [
	<!ENTITY % extensions SYSTEM "../stylesheets/macros.ent" >
	<!ENTITY % DocBookDTD PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	<!ENTITY % entities SYSTEM "../stylesheets/macros-de.ent" >
	%extensions;
	%DocBookDTD;
	%entities;
]>
<chapter id="import">
  <title>Pre- und Post-Hook-Skripte für den Import</title>
  <para>
	Während des Datenimports kann es notwendig sein, dass in Abhängigkeit von der
	jeweiligen Umgebung zusätzlich einige weitere Einstellungen vorgenommen werden
	müssen. Mit den Pre- und Post-Hook-Skripten besteht die Möglichkeit vor und
	nach dem Import eines Objektes, Skripte auszuführen. Zu allen Objekten und den
	davon jeweils unterstützten Operationen können mehrere Skripte definiert
	werden, die dann vor und nach den Operationen Anpassungen vornehmen.
  </para>
  <caution>
    <para>
      Hook-Skripte werden zu &ucsUAS; Version 5.0 abgekündigt.
      Mit &ucsUAS; Version 4.4 v9 wurden Python-basierte Hooks eingeführt, welche ihre Funktion übernehmen.
      Ihre Funktionalität wird unten, in <xref linkend="import:pyhooks"/> erklärt.
    </para>
  </caution>
  <para>
	Damit die Import-Skripte die Hook-Skripte finden können, müssen diese unterhalb
	des Verzeichnisses <filename>/usr/share/ucs-school-import/hooks/</filename> abgelegt
	werden. Dort gibt es für jede unterstützte Operation ein eigenes
	Unterverzeichnis. Beispielsweise gibt es das Verzeichnis
	<filename>user_create_pre.d</filename>, das alle Skripte enthalten muss, die vor dem
	Import eines Benutzers ausgeführt werden sollen. Alle weiteren Verzeichnisse
	sind nach dem gleichen Schema benannt: <filename><replaceable>&lt;Objekt&gt;</replaceable>_<replaceable>&lt;Operation&gt;</replaceable>_pre.d</filename>
	für die Skripte, die <emphasis>vor</emphasis> einer Operation ausgeführt werden sollen
	und <filename><replaceable>&lt;Objekt&gt;</replaceable>_<replaceable>&lt;Operation&gt;</replaceable>_post.d</filename> für die Skripte, die nach einer
	Operation ausgeführt werden sollen. Das Paket <package>ucs-school-import</package>
	bringt diese Verzeichnisse bereits mit. Skripte, die bei der Ausführung
	berücksichtigt werden sollen, müssen zwei Bedingungen erfüllen. Der Name darf
	nur aus Ziffern, Buchstaben und Unter- und Bindestrichen bestehen und die
	Ausführungsrechte müssen für die Datei gesetzt sein. Alle anderen Dateien in
	diesen Verzeichnissen werden ignoriert.
  </para>
  <para>
	Die Hook-Skripte werden derzeit für die Objekttypen <classname>ou</classname>, <classname>user</classname>,
	<classname>group</classname>, <classname>printer</classname>, <classname>computer</classname>, <classname>network</classname> und <classname>router</classname>
	für die Operationen <option>create</option>, <option>modify</option> und <option>remove</option> ausgeführt.
	Dabei ist zu beachten, dass für Rechner (<foreignphrase>computer</foreignphrase>), Netzwerke, Router und Schul-OUs
	nur die Operation zum Erzeugen (<option>create</option>) definiert ist und daher auch nur dafür
	Hook-Skripte definiert werden können.
  </para>
  <para>
	Die Pre-Hook-Skripte werden mit einem Parameter aufgerufen. Dieser enthält den
	Namen einer Datei in der die Zeile des als nächstes zu bearbeitenden Objektes
	aus der Import-Datei gespeichert ist. Darüber können die Skripte jede
	Einstellung für das Objekt auslesen; allerdings ist zu berücksichtigen, dass
	zu diesem Zeitpunkt die Daten noch nicht durch das Import-Skript geprüft
	worden sind. Die Post-Hook-Skripte bekommen als zusätzlichen Parameter noch
	den LDAP-DN des gerade bearbeiteten Objektes übergeben.
  </para>
  <para>
	Das folgende Beispiel-Skript soll ausgeführt werden, nachdem eine neue
	Schul-OU angelegt wurde. Dafür muss das Skript in das Verzeichnis
	<filename class="directory">/usr/share/ucs-school-import/hooks/ou_create_post.d/</filename> kopiert
	werden. Die Aufgabe des Skriptes soll es sein, die LDAP-Basis für den
	DHCP-Server der Schule per &ucsUCR;-Richtlinie auf den Container
	<uri>cn=dhcp</uri> unterhalb der LDAP-Basis der Schule zu setzen.
  </para>
  <programlisting language="sh">
#!/bin/sh
ldap_base="$(ucr get ldap/base)"
# Auslesen der ersten Spalte (OU-name) der Importdatei
ou="$(awk -F '\t' '{print $1}' "$1")"
# Den Standard-Schul-DC-Namen erzeugen
host="dc${ou}.$(ucr get domainname)"
# Eine UCR-Richtlinie erstellen und mit dem Schul-DC verbinden
udm policies/registry create \
  --position "cn=policies,ou=$ou,$ldap_base" \
  --set name=dhcpd_ldap_base \
  --append "registry=dhcpd/ldap/base=cn=dhcp,ou=$ou,$ldap_base"
udm computers/domaincontroller_slave \
  --dn "cn=dc${ou},cn=dc,cn=computers,ou=$ou,$ldap_base" \
  --policy-reference "cn=dhcpd_ldap_base,cn=policies,ou=$ou,$ldap_base"
echo "$(basename $0): Added policy dhcpd_ldap_base ."</programlisting>
  <para>
	Obwohl das Skript <command>create_ou</command> keine Eingabedatei übergeben bekommt,
	wird für die Hook-Skripte eine generiert, die in der Zeile den Namen der OU
	enthält. Wenn ein vom Standard abweichender Schul-DC-Name angegeben wurde,
	wird dieser als zweiter Wert übergeben. Für alle anderen Operationen auf den
	Objekten können Hook-Skripte auf äquivalente Weise erstellt werden.
  </para>

  <section id="import:extend">
	<title>Erweiterung von Importdateien</title>
	<para>
	  Eine weitere Funktion von den Hook-Skripten ist die Möglichkeit mit
	  Erweiterungen in den Import-Dateien umzugehen, d.h. wenn in den Importdateien
	  mehr Felder eingetragen sind, als durch die Import-Skripte selbst
	  verarbeitet werden, so können die erweiterten Attribute in den Hook-Skripten
	  ausgelesen und verarbeitet werden. Als Beispiel könnten bei den Benutzern
	  Adressinformationen oder eine Abteilung gespeichert werden. Die zusätzlichen
	  Felder werden in den Importdateien jeweils hinten an die Zeilen getrennt durch
	  einen Tabulator angehängt. Da die Hook-Skripte die komplette Zeile übergeben
	  bekommen, kann ein Post-Hook-Skript genutzt werden, um die neuen Felder auszulesen
	  und die Informationen z.B. an dem gerade erzeugten Benutzer zu ergänzen.
	</para>
  </section>

  <section id="import:marketplace">
	<title>Beispiel-Hook-Skript: automatische Erstellung der Marktplatzfreigabe</title>
	<para>
	  Um den Austausch von Dokumenten zwischen Benutzern zu erleichtern, wird
	  empfohlen, die Freigabe <emphasis>Marktplatz</emphasis> auf den jeweiligen Schul-DCs
	  anzulegen, auf die alle Benutzer Zugriff erhalten.
	</para>
	<para>
	  Das Hook-Skript <command>ou_create_post.d/52marktplatz_create</command> wurde ab &ucsUAS;
	  für UCS 2.4 mitgeliefert und legte beim Aufruf von <command>create_ou</command> die
	  Freigabe ``Marktplatz'' automatisch an.
      Seit &ucsUAS; 4.4 v8 existiert der Hook nicht mehr als separate Datei, da er in den Kern von &ucsUAS; übernommen wurde. Über
	  die &ucsUCRV; <envar>ucsschool/import/generate/share/marktplatz</envar> kann das Anlegen der Freigabe
	  de-/aktiviert werden, indem der Variable der Wert <literal>no</literal> bzw. <literal>yes</literal>
	  zugeordnet wird.
	</para>
	<para>
	  Über drei weitere &ucsUCR;-Variablen kann das Verhalten des Hooks gesteuert
	  werden:
	</para>
	  <itemizedlist>
		<listitem>
		  <para>
			<command>ucsschool/import/generate/share/marktplatz/sharepath</command>
		  </para>
		  <para>
			Diese Variable definiert das Verzeichnis auf dem Server, welches als
			Freigabe <systemitem class="resource">Marktplatz</systemitem> freigegeben wird. In der Standardeinstellung wird das Verzeichnis
			<filename>/home/&lt;OU&gt;/groups/Marktplatz</filename> verwendet.
		  </para>
		</listitem>
		<listitem>
		  <para>
			<command>ucsschool/import/generate/share/marktplatz/group</command>
		  </para>
		  <para>
			Beim Anlegen der Freigabe wird die in dieser Variable definierte Gruppe
			als Gruppenbesitzer der Freigabe festgelegt. In der Standardeinstellung
			ist	dies die Gruppe <systemitem class="groupname">Domain Users</systemitem>. Es ist zu beachten, dass abweichend vom UCS-Standard
			die über die Importskripte angelegten Benutzer nicht in der Gruppe <systemitem class="groupname">Domain Users</systemitem> enthalten sind.
		  </para>
		</listitem>
		<listitem>
		  <para>
			<command>ucsschool/import/generate/share/marktplatz/permissions</command>
		  </para>
		  <para>
			Die Zugriffsrechte der Freigabe sind in oktaler Schreibweise anzugeben
			(z.B. 0777). In der Standardeinstellung erhalten der Benutzer <systemitem class="username">root</systemitem>,
			die vordefinierte Gruppe (z.B. <systemitem class="groupname">Domain Users</systemitem>) sowie alle sonstigen Benutzer Lese- und
			Schreibrechte (0777).
		  </para>
		</listitem>
	  </itemizedlist>
  </section>

  <section id="import:dhcp">
	<title>Beispiel-Hook-Skript: Setzen des LDAP-Containers für DHCP-Objekte</title>
	<para>
	  Auf den Schul-DCs wird ein abweichender Container für DHCP-Objekte
	  verwendet, weshalb die &ucsUCRV; <envar>dhcpd/ldap/base</envar> entsprechend gesetzt werden
	  muss. Um das manuelle Setzen der UCR-Variable für jede neue OU bzw. jeden
	  neuen Schul-DC zu vermeiden, wird automatisch beim Erstellen einer OU die
	  UCR-Richtlinie <uri>ou-default-ucr-policy</uri> im Container
	  <uri>cn=policies,ou=<replaceable>XXX</replaceable>,<replaceable>LDAPBASIS</replaceable></uri> angelegt und anschließend mit dem OU-Objekt <uri>ou=<replaceable>XXX</replaceable>,<replaceable>LDAPBASIS</replaceable></uri>
	  verknüpft. Bis &ucsUAS; 4.4 v8 tat dies der Hook <command>ou_create_post.d/40dhcpsearchbase_create</command>, mittlerweile ist diese Funktion im Kern.
      Über die Richtlinie wird die &ucsUCRV; <envar>dhcpd/ldap/base</envar>
	  entsprechend gesetzt. Dadurch wird sichergestellt, dass die in der Richtlinie
	  gesetzten UCR-Variablen auf allen UCS-Systemen der OU
	  automatisch übernommen werden.
	</para>
  </section>

  <section id="import:pyhooks">
      <title>Python-Hooks</title>
      <para>
          Ab &ucsUAS; 4.4 v9 kann vor und nach dem Anlegen, Ändern, Verschieben und Löschen von &ucsUAS; Objekten Python-Code ausgeführt werden.
          Die im vorherigen Kapitel beschriebenen Hook-Skripte werden ab &ucsUAS; 5.0 nicht mehr unterstützt.
      </para>
      <para>
          Python-Hooks (im folgenden Abschnitt abgekürzt mit "Hooks") werden wesentlich schneller ausgeführt als Hook-Skripte, erlauben eine feingranulare Unterscheidung nach Objekttypen (z.B. Schulklasse und Arbeitsgruppe oder Schüler und Lehrer) und haben Zugriff auf alle Attribute der Objekte.
      </para>
      <para>
          Die Hooks werden für alle Klassen, von denen Objekte erzeugt werden können und die von <classname>ucsschool.lib.models.base.UCSSchoolHelperAbstractClass</classname> ableiten, ausgeführt.
          Diese Klassen finden sich in im Python Paket <classname>ucsschool.lib.models</classname> (z.B. <classname>Student</classname>, <classname>SchoolClass</classname>, <classname>Workgroup</classname>).
      </para>
      <caution>
          <para>
              Hooks werden nur auf dem System ausgeführt, auf dem sie installiert sind.
              In der Regel ist das der Primary Directory Node (DC Master), sowie alle Backup Directory Nodes (DC Backups).
              Sollen Hooks auch auf Replication Nodes (DC Slave) ausgeführt werden, so müssen sie auch dort installiert werden.
              Eine automatische Verteilung der Hook Dateien findet nicht statt.
          </para>
      </caution>
      <para>
          Hooks für &ucsUAS; Objekte ähneln den bekannten Hooks für den Benutzerimport (siehe <biblioref linkend="ucs-school-cli-import"/>), werden jedoch auch ohne den Import zu verwenden ausgeführt und haben einige andere Attribute.
      </para>
      <para>
          Zur Nutzung der Hook-Funktionalität muss eine eigene Python-Klasse erstellt werden, die von <classname>ucsschool.lib.models.hook.Hook</classname> ableitet.
          In der Klasse können Methoden <methodname>pre_create()</methodname>, <methodname>post_create()</methodname>, etc. definiert werden, welche zum jeweiligen Zeitpunkt ausgeführt werden.
          Der Name der Datei mit der abgeleiteten Klasse muss auf <filename>.py</filename> enden und im Verzeichnis <filename class="directory">/var/lib/ucs-school-lib/hooks</filename> abgespeichert werden.
          Zwei Beispiele finden sich auf Servern der Rolle Primary Directory Node (DC Master) in <filename>hook_example1.py</filename> und <filename>hook_example2.py</filename> unter <filename class="directory">/usr/share/doc/ucs-school-lib-common/</filename> bzw. online auf <ulink url="https://github.com/univention/ucs-school/blob/4.4/ucs-school-lib/usr/share/doc/ucs-school-lib-common/hook_example1.py">https://github.com/.../hook_example1.py</ulink> und <ulink url="https://github.com/univention/ucs-school/blob/4.4/ucs-school-lib/usr/share/doc/ucs-school-lib-common/hook_example2.py">https://github.com/.../hook_example2.py</ulink>.
          Im Folgenden wird anhand des Beispiels in <filename>hook_example2.py</filename> erklärt, wie mit Hilfe eines Hooks jeder Schulklasse eine Email-Adresse zugeordnet werden kann.
      </para>
      <caution>
          <para>
              Das Beispiel ist lauffähig, aber nicht für den Produktivbetrieb geeignet.
              Dafür bräuchte es u.a. zusätzlichen Code, um robust mit existierenden Email-Adressen umzugehen.
          </para>
      </caution>
      <para>
          Ein Python-Hook ist eine Klasse, die von <classname>ucsschool.lib.models.hook.Hook</classname> ableitet und einige Attribute und Methoden definiert.
          <programlisting language="python">
from ucsschool.lib.models.group import SchoolClass
from ucsschool.lib.models.hook import Hook

class MailForSchoolClass(Hook):
    model = SchoolClass
    priority = {
        "post_create": 10,
        "post_modify": 10,
    }

    def post_create(self, obj):  # type: (SchoolClass) -> None
        ...

    def post_modify(self, obj):  # type: (SchoolClass) -> None
        ...
          </programlisting>
      </para>
      <para>
          Das Klassenattribut <property>model</property> bestimmt, für welche Objekte welchen Typs der Hook ausgeführt wird.
          Der Hook wird auch für Objekte von Klassen ausgeführt, die von der angegebenen ableiten.
          Wäre <code>model = Teacher</code> (aus <classname>ucsschool.lib.models</classname>), so würde der Hook auch für Objekte der Klasse <classname>TeachersAndStaff</classname> ausgeführt, nicht aber für solche vom Typ <classname>Staff</classname> oder <classname>Student</classname>.
      </para>
      <para>
          Das Klassenattribut <property>priority</property> bestimmt die Reihenfolge in der Methoden von Hooks des gleichen Typs (gleiches <property>model</property>) ausgeführt werden bzw. deaktiviert sie.
          Methoden mit höheren Zahlen werden zuerst ausgeführt.
          Ist der Wert <varname>None</varname> oder die Methode nicht aufgeführt, wird sie deaktiviert.
          Angenommen es gäbe eine weitere Klasse mit einem Hook mit <code>model = SchoolClass</code> und diese würde <code>priority = {"post_create": 20}</code> definieren, so würde deren <methodname>post_create()</methodname> Methode <emphasis>vor</emphasis> <methodname>MailForSchoolClass.post_create()</methodname> ausgeführt.
      </para>
      <para>
          Alle Methoden der Klasse, z.B. <methodname>pre_create()</methodname> oder <methodname>post_create()</methodname>, empfangen ein Objekt vom Typ, bzw. des davon abgeleiteten Typs, der in <property>model</property> definiert wurde, als Argument <varname>obj</varname> und geben nichts zurück.
      </para>
      <para>
          Die <methodname>post_create()</methodname> Methode sieht wie folgt aus:
          <programlisting language="python">
def post_create(self, obj):  # type: (SchoolClass) -> None
"""
Create an email address for the new school class.

:param SchoolClass obj: the SchoolClass instance, that was just created.
:return: None
"""
    ml_name = self.name_for_mailinglist(obj)
    self.logger.info("Setting email address %r on school class %r...", ml_name, obj.name)
    udm_obj = obj.get_udm_object(self.lo)  # access the underlying UDM object
    udm_obj["mailAddress"] = ml_name
    udm_obj.modify()
          </programlisting>
          Die Klasse <classname>SchoolClass</classname> bietet kein Attribut an, um eine Email-Adresse anzugeben.
          Die Klassen in <classname>ucsschool.lib.models</classname> sind jedoch tatsächlich eine Abstraktion regulärer &ucsUDM; Objekte.
          Um auf auf die darunter liegenden Objekte zuzugreifen, wird die Methode <methodname>get_udm_object()</methodname> verwendet.
          Als Argument muss ihr ein sogenanntes LDAP Verbindungsobjekt (<varname>lo</varname>) mitgegeben werden.
      </para>
      <para>
          Die Instanzvariablen <property>self.lo</property>, <property>self.logger</property> und <property>self.ucr</property> sind nach der Ausführung von <methodname>__init__()</methodname> verfügbar.
          Es handelt sich bei ihnen um die Instanz eines LDAP Verbindungsobjekts, einer Instanz von Python <classname>Logging</classname> und einer Instanz von &ucsUCR;.
          Soll eigener Code zur Initialisierung ausgeführt werden, so sollte <methodname>__init__()</methodname> folgendermaßen implementiert werden:
          <programlisting language="python">
class MailForSchoolClass(Hook):
    def __init__(self, lo, *args, **kwargs):
        super(MailForSchoolClass, self).__init__(lo, *args, **kwargs)
        # From here on self.lo, self.logger and self.ucr are available.
        # You code here.
          </programlisting>
      </para>
      <para>
          Zwei Funktionen helfen dabei, aus dem Namen der Schulklasse und einem Domänennamen, eine Email-Adresse zu erzeugen:
          <programlisting language="python">
def name_for_mailinglist(self, obj):  # type: (SchoolClass) -> str
    return "{}@{}".format(obj.name, self.domainname).lower()

@property
def domainname(self):  # type: () -> str
    try:
        return self.ucr["mail/hosteddomains"].split()[0]
    except (AttributeError, IndexError):
        return self.ucr["domainname"]
          </programlisting>
      </para>
      <para>
          Um Email-Adresse auch für umbenannte Schulklassen zu ändern, wird <methodname>post_modify</methodname> implementiert:
          <programlisting language="python">
def post_modify(self, obj):  # type: (SchoolClass) -> None
    """
    Change the email address of an existing school class.

    :param SchoolClass obj: the SchoolClass instance, that was just modified.
    :return: None
    """
    udm_obj = obj.get_udm_object(self.lo)
    ml_name = self.name_for_mailinglist(obj)
    if udm_obj["mailAddress"] != ml_name:
        self.logger.info(
            "Changing the email address of school class %r from %r to %r...",
            obj.name,
            udm_obj["mailAddress"],
            ml_name,
        )
        udm_obj["mailAddress"] = ml_name
        udm_obj.modify()
          </programlisting>
      </para>
      <para>
          Die Datei mit obigem Python Code kann nun im Verzeichnis <filename class="directory">/var/lib/ucs-school-lib/hooks</filename> abgespeichert werden.
          Soll der Hook von einem UMC-Modul verwendet werden, muss zuerst der UMC-Server neu gestartet werden:
          <programlisting language="sh">
service univention-management-console-server restart
          </programlisting>
          Um den Hook zu testen, kann eine interaktive Python Shell verwendet werden.
          Einige Ausgaben wurden im folgenden Beispiel zur Verbesserung der Lesbarkeit gekürzt:
          <programlisting language="python">
>>> import logging
>>> from ucsschool.lib.models.group import SchoolClass
>>> from univention.admin.uldap import getAdminConnection

>>> logging.basicConfig(level=logging.DEBUG, format="%(message)s", handlers=[logging.StreamHandler()])
>>> lo, _ = getAdminConnection()

>>> sc = SchoolClass(name="DEMOSCHOOL-igel", school="DEMOSCHOOL")
>>> sc.create(lo)

Starting SchoolClass.call_hooks('pre', 'create', lo('cn=admin,dc=exam,dc=ple')) for SchoolClass(
    name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-igel,cn=klassen,cn=schueler,
    cn=groups,ou=DEMOSCHOOL,dc=exam,dc=ple').
Hook directory /usr/share/ucs-school-import/hooks/group_create_pre.d not found or empty.
Searching for hooks of type 'Hook' in: /var/lib/ucs-school-lib/hooks...
Found hook classes: MailForSchoolClass
Loaded hooks: {'post_modify': ['MailForSchoolClass.post_modify'], 'post_create': [
    'MailForSchoolClass.post_create']}.
Creating SchoolClass(name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='...')
SchoolClass(name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='...') successfully created
Starting SchoolClass.call_hooks('post', 'create', lo('cn=admin,dc=uni,dc=dtr')) for SchoolClass(
    name='DEMOSCHOOL-igel', school='DEMOSCHOOL', dn='...').
Hook directory /usr/share/ucs-school-import/hooks/group_create_post.d not found or empty.
Running post_create hook MailForSchoolClass.post_create for SchoolClass(name='DEMOSCHOOL-igel',
    school='DEMOSCHOOL', dn='...')...
Setting email address 'demoschool-igel@uni.dtr' on SchoolClass(name='DEMOSCHOOL-igel',
    school='DEMOSCHOOL', dn='...')...
True

>>> sc.name = "DEMOSCHOOL-hase"
>>> sc.modify(lo)

Starting SchoolClass.call_hooks('pre', 'modify', lo('cn=admin,dc=exam,dc=ple')) for SchoolClass(
    name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...', old_dn='cn=DEMOSCHOOL-igel,...').
Hook directory /usr/share/ucs-school-import/hooks/group_modify_pre.d not found or empty.
Modifying SchoolClass(name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...',
    old_dn='cn=DEMOSCHOOL-igel,...')
SchoolClass(name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...') successfully modified
Starting SchoolClass.call_hooks('post', 'modify', lo('cn=admin,dc=exam,dc=ple')) for SchoolClass(
    name='DEMOSCHOOL-hase', school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...').
Hook directory /usr/share/ucs-school-import/hooks/group_modify_post.d not found or empty.
Running post_modify hook MailForSchoolClass.post_modify for SchoolClass(name='DEMOSCHOOL-hase',
    school='DEMOSCHOOL', dn='cn=DEMOSCHOOL-hase,...')...
Changing the email address of SchoolClass(name='DEMOSCHOOL-hase', school='DEMOSCHOOL', ...)
    from 'demoschool-igel@example.com' to 'demoschool-hase@example.com'...
True
          </programlisting>
          Vor dem Anlegen des Objekts wird in <filename class="directory">/usr/share/ucs-school-import/hooks/group_create_pre.d/</filename> nach den Hook-Skripte  gesucht, welche ab &ucsUAS; 5.0 nicht mehr unterstützt werden.
          Anschließend wird in <filename class="directory">/var/lib/ucs-school-lib/hooks/</filename> nach Python-Hooks gesucht und die Klasse <classname>MailForSchoolClass</classname> gefunden.
          Nach dem Laden aller Hooks wird angezeigt, in welcher Reihenfolge welche Methoden für welche Phase ausgeführt werden.
          Da es keine <varname>pre-create</varname> Hooks gibt, wird nun das Objekt angelegt.
          Anschließend werden <varname>post-create</varname> Hooks ausgeführt.
          Erneut wird zuerst nach Hook-Skripten gesucht.
          Anschließend wird <methodname>MailForSchoolClass.post_create()</methodname> ausgeführt.
          Beim <methodname>sc.modify(lo)</methodname> passiert das Gleiche.
      </para>
  </section>
</chapter>
